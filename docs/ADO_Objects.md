## Objects
When a database table is mapped into an Ada object, the application holds a reference
to that object through the `Object_Ref` type.
The `Object_Ref` tagged type is the root type of any database record reference.
Reference counting is used so that the object can be stored, shared and the memory
management is handled automatically.  It defines generic operations to be able to:

  * load the database record and map it to the Ada object,

  * save the Ada object into the database either by inserting or updating it,

  * delete the database record.

The Dynamo code generator will generate a specific tagged type for each database table
that is mapped.  These tagged type will inherit from the `Object_Ref` and will implement
the required abstract operations.  For each of them, the code generator will generate
the `Get_X` and `Set_X` operation for each column mapped in Ada.

Before the `Object_Ref` is a reference, it does not hold the database record itself.
The `ADO.Objects.Object_Record` tagged record is used for that and it defines the
root type for the model representation.  The type provides operations to modify a
data field of the record while tracking its changes so that when the `Save` operation
is called, only the data fields that have been modified are updated in the database.
An application will not use nor access the `Object_Record`.  The Dynamo code generator
generates a private type to make sure it is only accessed through the reference.

Several predicate operations are available to help applications check the validity
of an object reference:

| Function    | Description |
| ----------- |--------------------------------------------------------- |
| Is_Null     | When returning True, it indicates the reference is NULL. |
| Is_Loaded   | When returning True, it indicates the object was loaded from the database. |
| Is_Inserted | When returning True, it indicates the object was inserted in the database. |
| Is_Modified | When returning True, it indicates the object was modified and must be saved. |

Let's assume we have a `User_Ref` mapped record, an instance of the reference would
be declared as follows:

```Ada
with Samples.User.Model;
...
  User : Samples.User.Model.User_Ref;
```

After this declaration, the reference is null and the following assumption is true:

```Ada
User.Is_Null and not User.Is_Loaded and not User.Is_Inserted
```

If we set a data field such as the name, an object is allocated and the reference
is no longer null.

```Ada
User.Set_Name ("Ada Lovelace");
```

After this statement, the following assumption is true:

```Ada
not User.Is_Null and not User.Is_Loaded and not User.Is_Inserted
```

With this, it is therefore possible to identify that this object is not yet
saved in the database.  After calling the `Save` procedure, a primary key is
allocated and the following assumption becomes true:

```Ada
not User.Is_Null and not User.Is_Loaded and User.Is_Inserted
```

## Loading Objects
Three operations are generated by the Dynamo code generator to help in loading
a object from the database: two `Load` procedures and a `Find` procedure.
The `Load` procedures are able to load an object by using its primary key.
Two forms of `Load` are provided: one that raises the `ADO.Objects.NOT_FOUND`
exception and another that returns an additional `Found` boolean parameter.
Within the application, if the database row is expected to exist, the first
form should be used.  In other cases, when the application expects that the
database record may not exist, the second form is easier and avoids raising
and handling an exception for a common case.

```Ada
 User.Load (Session, 1234);
```

The `Find` procedure allows to retrieve a database record by specifying a
filter.  The filter object is represented by the `ADO.SQL.Query` tagged record.
A simple query filter is declared as follows:

```Ada
Filter : ADO.SQL.Query;
```

The filter is an SQL fragment that is inserted within the `WHERE` clause to
find the object record.  The filter can use parameters that are configured
by using the `Bind_Param` or `Add_Param` operations.  For example, to find
a user from its name, the following filter could be set:

```Ada
Filter.Set_Filter ("name = :name");
Filter.Bind_Param ("name", "Ada Lovelace");
```

Once the query filter is initialized and configured with its parameters,
the `Find` procedure can be called:

```Ada
Found : Boolean;
...
User.Find (Session, Filter, Found);
```

The `Find` procedure does not raise an exception if the database record is not found.
Instead, it returns a boolean status in the `Found` output parameter.  The `Find`
procedure will execute an SQL `SELECT` statement with a `WHERE` clause to retrieve
the database record.  The `Found` output parameter is set when the query returns
exactly one row.

## Modifying Objects
To modify an object, applications will use one of the `Set_X` operation generated
for each mapped column.  The ADO runtime will keep track of which data fields are
modified.  The `Save` procedure must be called to update the database record.
When calling it, an SQL `UPDATE` statement is generated to update the modified
data fields.

```Ada
User.Set_Status (1);
User.Save (Session);
```

## Deleting Objects
Deleting objects is made by using the `Delete` operation.

```Ada
User.Delete (Session);
```

Sometimes you may want to delete an object without having to load it first.
This is possible by delete an object without loading it.  For this, set the
primary key on the object and call the `Delete` operation:

```Ada
User.Set_Id (42);
User.Delete (Session);
```

## Sequence Generators
The sequence generator is responsible for creating unique ID's
across all database objects.

Each table can be associated with a sequence generator.
The sequence factory is shared by several sessions and the
implementation is thread-safe.

The `HiLoGenerator` implements a simple High Low sequence generator
by using sequences that avoid to access the database.

Example:

```Ada
F  : Factory;
Id : Identifier;
...
  Allocate (Manager => F, Name => "user", Id => Id);
```

### HiLo Sequence Generator
The HiLo sequence generator.  This sequence generator uses a database table
`sequence` to allocate blocks of identifiers for a given sequence name.
The sequence table contains one row for each sequence.  It keeps track of
the next available sequence identifier (in the `value column).

To allocate a sequence block, the HiLo generator obtains the next available
sequence identified and updates it by adding the sequence block size.  The
HiLo sequence generator will allocate the identifiers until the block is
full after which a new block will be allocated.

